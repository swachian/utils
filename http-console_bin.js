// Generated by CoffeeScript 1.3.3
(function() {
  var Console, arg, args, argv, auth, colors, console, consoles, events, fs, help, host, hostport, http, https, inspect, matches, option, options, port, print, protocol, puts, querystring, readline, url, util, _i, _len,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  util = require('util');

  colors = require('colors');

  http = require('http');

  https = require('https');

  fs = require('fs');

  events = require('events');

  querystring = require('querystring');

  readline = require('readline');

  print = util.print;

  puts = util.puts;

  inspect = require('eyes').inspector();

  help = ['usage: http-console [username:password@host:port] [options]', '', 'options:', '    --cookies      remember cookies', '-v, --verbose      print requests', '    --json         set "Content-Type" header to application/json', '    --notimeout    don\'t timeout requests', '    --ssl          create a secure connection', '    --version      print version', '-h, --help         display this message'].join("\n");

  options = {
    rememberCookies: true,
    useSSL: "protocol == 'https'",
    json: false,
    timeout: true,
    verbose: false
  };

  argv = process.argv.slice(2);

  args = [];

  for (_i = 0, _len = argv.length; _i < _len; _i++) {
    arg = argv[_i];
    if ((matches = arg.match(/^--?([\w-]+)$/))) {
      option = matches[1];
      switch (option) {
        case 'cookies':
          options.rememberCookies = true;
          break;
        case 'non-cookies':
          options.rememberCookies = false;
          break;
        case 'h':
        case 'help':
          puts(help);
          process.exit(0);
          break;
        default:
          puts("http-console: unrecognized option '" + matches[0] + "'");
      }
    } else {
      args.push(arg);
    }
  }

  url = args.shift() || "http://n:p@127.0.0.1:8080";

  protocol = url.match(/^(https?)?/)[0] || 'http';

  url = url.replace(protocol + '://', '').split("@");

  hostport = url.pop().split(":");

  auth = url.pop();

  host = hostport.shift();

  port = hostport.shift() || 80;

  if (auth) {
    auth = auth.split(":");
    options.auth = {
      username: auth.shift(),
      password: auth.shift()
    };
  }

  puts(hostport, auth, host, port);

  inspect(options.auth);

  /* 编写console
  */


  consoles = [];

  Console = (function() {
    /* 构造函数
      host - 
      port -
      options - 输入的一些关于cookie、session等的选项
    */

    function Console(host, port, options) {
      this.exec = __bind(this.exec, this);

      this.setCookies = __bind(this.setCookies, this);

      this.request = __bind(this.request, this);
      this.host = host;
      this.port = parseInt(port);
      this.options = options;
      this.timeout = this.options.timeout ? 5000 : 0;
      this.path = [];
      this.socket = null;
      this.cookies = {};
      consoles.push(this);
    }

    /* 初始函数     建立console实例后即刻调用
    Example:
       console = new(httpConsole.Console)(host, port, options);
       console.initialize()
     返回 对象本身 this
    */


    Console.prototype.initialize = function() {
      var _this = this;
      this.welcome();
      this.headers = {
        'Accept': '*/*'
      };
      if (this.options.auth) {
        this.headers['Authorization'] = "Basic " + new Buffer(this.options.auth.username + ':' + this.options.auth.password).toString('base64');
      }
      this.readline = readline.createInterface(process.stdin, process.stdout);
      this.readline.on('line', function(cmd) {
        return _this.exec(cmd.trim());
      }).on('close', function() {
        process.stdout.write("\n");
        return process.exit(0);
      });
      this.prompt();
      http.globalAgent.maxSockets = 2000;
      return this;
    };

    /* welcome 欢迎致辞函数
    */


    Console.prototype.welcome = function() {
      puts("> " + ("http-console " + '1.0').bold, "> Welcome, enter .help if you're lost.", "> Connecting to " + this.host + " on port " + this.port + '.');
      return puts();
    };

    /* 发起请求
    method - the string of http access method
    path - the string of path
    headers - the hash 
    callback - 呼叫函数，代码块
     返回 request
    */


    Console.prototype.request = function(method, path, headers, callback) {
      var k, request, _j, _len1, _ref,
        _this = this;
      this.headers['Host'] = this.host;
      _ref = this.headers;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        k = _ref[_j];
        headers[k] = this.headers[k];
      }
      method = method.toUpperCase();
      path = encodeURI(path);
      this.setCookies(headers);
      request = (this.options.useSSL ? https : http).request({
        host: this.host,
        port: this.port,
        method: method,
        path: path,
        headers: headers
      }, function(res) {
        var body;
        body = "";
        res.setEncoding('utf8');
        if (this.options.rememberCookies) {
          this.rememberCookies(res.headers);
        }
        res.on('data', function(chunk) {
          return body += chunk;
        });
        return res.on('end', function() {
          return callback(res, body);
        });
      }).on('error', function(e) {
        util.error(e.toString().red);
        return _this.prompt();
      });
      return request;
    };

    /* 设置cookies
    headers - the hash
    
    Example:
      setCookies(headers)
    */


    Console.prototype.setCookies = function(headers) {
      var header, keys,
        _this = this;
      if ((keys = Object.keys(this.cookies)).length) {
        header = keys.filter(function(k) {
          options = _this.cookies[k].options;
          return true;
        }).map(function(k) {
          return [k, querystring.escape(this.cookies[k].value) || ''].join('=');
        }).join(', ');
        return header && (headers['Cookie'] = header);
      }
    };

    /* prompt 命令行前的提示
    */


    Console.prototype.prompt = function() {
      var arrow, length, path;
      path = '/' + this.path.join('/');
      host = "" + this.host + ":" + this.port;
      arrow = '>';
      length = (host + path + arrow).length;
      this.readline.setPrompt(host.grey + path + arrow.grey, length);
      return this.readline.prompt();
    };

    /* exec 执行脚本输入，控制操作函数
    command - The string to be executed
    */


    Console.prototype.exec = function(command) {
      var headers, match, method, path, req,
        _this = this;
      headers = {};
      path = this.path;
      if (this.pending) {
        req = this.request(this.pending.method, this.pending.path, {
          'Content-length': command.length
        }, function(res, body) {
          return _this.printResponse(res, body, function() {
            return _this.prompt();
          });
        });
        req.write(command);
        req.end();
        this.pending = null;
      } else if (command[0] === '/') {
        if (command === '//') {
          this.path = [];
        } else {
          Array.prototype.push.apply(this.path, command.slice(1).split('/'));
        }
      } else if (command === '..') {
        this.path.pop();
      } else if (command[0] === '.') {
        switch (command.slice(1)) {
          case 'h':
          case 'headers':
            exports.merge(headers, this.headers);
            this.setCookies(headers);
            this.printHeaders(headers);
            break;
          case 'default-headers':
            this.printHeaders(this.headers);
            break;
          case 'o':
          case 'options':
            inspect(this.options);
            break;
          case 'c':
          case 'cookies':
            inspect(this.cookies);
            break;
          case 'help':
            puts(help);
            break;
          case 'j':
          case 'json':
            this.headers['Content-Type'] = 'application/json';
            break;
          case 'exit':
          case 'quit':
          case 'q':
            process.exit(0);
        }
      } else if ((match = command.match(/^([a-zA-Z-]+):\s*(.*)/))) {
        if (match[2]) {
          this.headers[match[1]] = match[2];
        } else {
          delete this.headers[match[1]];
        }
      } else if (/^(GET|POST|PUT|HEAD|DELETE)/i.test(command)) {
        command = command.split(/\s+/);
        method = command.shift().toUpperCase();
        path = this.path.slice(0);
        if (command.length > 0) {
          path.push(command[0]);
        }
        path = ('/' + path.join('/')).replace(/\/+/g, '/');
        if (method === 'PUT' || method === 'POST') {
          this.pending = {
            method: method,
            path: path
          };
          this.dataPrompt();
        } else {
          this.request(method, path, {}, function(res, body) {
            return _this.printResponse(res, body, function() {
              return _this.prompt();
            });
          }).end();
        }
        return;
      } else if (command) {
        puts(("unknown command '" + command + "'").yellow.bold);
      }
      this.prompt();
      return {
        printResponse: function(res, body, callback) {
          var output, status;
          status = ("HTTP/" + res.httpVersion + " " + res.statusCode + " " + http.STATUS_CODES[res.statusCode]).bold;
          switch (res.statusCode) {
            case res.statusCode >= 500:
              status = status.red;
              break;
            case res.statusCode >= 400:
              status = status.yellow;
              break;
            case res.statusCode >= 300:
              status = status.cyan;
              break;
            default:
              status = status.green;
          }
          puts(status);
          printHeaders(res.headers);
          puts;

          try {
            output = JSON.parse(body);
          } catch (error) {
            output = body.trim();
          }
          if (typeof output === 'string') {
            output.length > 0 && print(output.white + '\n');
          } else {
            inspect(output);
          }
          if (process.stdout.write('')) {
            return callback();
          } else {
            return process.stdout.on('drain', function() {
              return callback();
            });
          }
        }
      };
    };

    return Console;

  })();

  console = new Console(host, port, options);

  console.initialize();

}).call(this);
